<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">
    <id>https://orange-hou.github.io/</id>
    <title>侯橙橙的博客</title>
    <updated>2020-03-15T15:26:13.123Z</updated>
    <generator>https://github.com/jpmonette/feed</generator>
    <link rel="alternate" href="https://orange-hou.github.io/"/>
    <link rel="self" href="https://orange-hou.github.io/atom.xml"/>
    <subtitle>如水般清澈，如酒般清冽，如茶般清雅</subtitle>
    <logo>https://orange-hou.github.io/images/avatar.png</logo>
    <icon>https://orange-hou.github.io/favicon.ico</icon>
    <rights>All rights reserved 2020, 侯橙橙的博客</rights>
    <entry>
        <title type="html"><![CDATA[向量检索初探]]></title>
        <id>https://orange-hou.github.io/post/xiang-liang-jian-suo-chu-tan/</id>
        <link href="https://orange-hou.github.io/post/xiang-liang-jian-suo-chu-tan/">
        </link>
        <updated>2020-02-03T13:16:59.000Z</updated>
        <content type="html"><![CDATA[<h2 id="一-何为向量检索">一、何为向量检索？</h2>
<p>提到向量这个词，相信大家都不会陌生，用几何数学知识解释就是带有方向的线段，那么向量搜索又是什么东西？我们先用一个二维直角坐标系来表示一下三个点向量A(1,2)、B(1,0)、C(0,2)：</p>
<blockquote>
<figure data-type="image" tabindex="1"><img src="https://orange-hou.github.io//post-images/1584285736041.png" alt="" loading="lazy"></figure>
</blockquote>
<p>根据如下欧几里得距离计算公式：</p>
<blockquote>
<p><span class="katex"><span class="katex-mathml"><math><semantics><mrow><mi>d</mi><mo>=</mo><msqrt><mrow><mo>(</mo><mi>x</mi><mn>0</mn><mo>−</mo><mi>x</mi><mn>1</mn><msup><mo>)</mo><mn>2</mn></msup><mo>+</mo><mo>(</mo><mi>y</mi><mn>0</mn><mo>−</mo><mi>y</mi><mn>1</mn><msup><mo>)</mo><mn>2</mn></msup></mrow></msqrt></mrow><annotation encoding="application/x-tex">d=\sqrt{(x0-x1)^2+(y0-y1)^2}</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.69444em;vertical-align:0em;"></span><span class="mord mathdefault">d</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span><span class="mrel">=</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span></span><span class="base"><span class="strut" style="height:1.24em;vertical-align:-0.30499999999999994em;"></span><span class="mord sqrt"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.935em;"><span class="svg-align" style="top:-3.2em;"><span class="pstrut" style="height:3.2em;"></span><span class="mord" style="padding-left:1em;"><span class="mopen">(</span><span class="mord mathdefault">x</span><span class="mord">0</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span><span class="mbin">−</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span><span class="mord mathdefault">x</span><span class="mord">1</span><span class="mclose"><span class="mclose">)</span><span class="msupsub"><span class="vlist-t"><span class="vlist-r"><span class="vlist" style="height:0.740108em;"><span style="top:-2.9890000000000003em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight">2</span></span></span></span></span></span></span></span><span class="mspace" style="margin-right:0.2222222222222222em;"></span><span class="mbin">+</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span><span class="mopen">(</span><span class="mord mathdefault" style="margin-right:0.03588em;">y</span><span class="mord">0</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span><span class="mbin">−</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span><span class="mord mathdefault" style="margin-right:0.03588em;">y</span><span class="mord">1</span><span class="mclose"><span class="mclose">)</span><span class="msupsub"><span class="vlist-t"><span class="vlist-r"><span class="vlist" style="height:0.740108em;"><span style="top:-2.9890000000000003em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight">2</span></span></span></span></span></span></span></span></span></span><span style="top:-2.8950000000000005em;"><span class="pstrut" style="height:3.2em;"></span><span class="hide-tail" style="min-width:1.02em;height:1.28em;"><svg width='400em' height='1.28em' viewBox='0 0 400000 1296' preserveAspectRatio='xMinYMin slice'><path d='M263,681c0.7,0,18,39.7,52,119c34,79.3,68.167,
158.7,102.5,238c34.3,79.3,51.8,119.3,52.5,120c340,-704.7,510.7,-1060.3,512,-1067
c4.7,-7.3,11,-11,19,-11H40000v40H1012.3s-271.3,567,-271.3,567c-38.7,80.7,-84,
175,-136,283c-52,108,-89.167,185.3,-111.5,232c-22.3,46.7,-33.8,70.3,-34.5,71
c-4.7,4.7,-12.3,7,-23,7s-12,-1,-12,-1s-109,-253,-109,-253c-72.7,-168,-109.3,
-252,-110,-252c-10.7,8,-22,16.7,-34,26c-22,17.3,-33.3,26,-34,26s-26,-26,-26,-26
s76,-59,76,-59s76,-60,76,-60z M1001 80H40000v40H1012z'/></svg></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.30499999999999994em;"><span></span></span></span></span></span></span></span></span></p>
</blockquote>
<p>我们可以计算出AB、AC的长度分别为2、1，因此，我们可以得出结论A离C更近，向量A与向量C更相似，这就是一个简单的向量搜索。除欧几里得距离之外，计算向量相似度还可以通过向量夹角的余弦值来实现，熟悉全文检索或者Lucene的同学应该知道有个向量空间模型的算法(VSM)，其中就是通过计算余弦值来得到向量相似度进行打分。</p>
<h2 id="二-向量聚类">二、向量聚类</h2>
<p>向量检索有两个基本参数，一个是n，表示需要用于检索的目标向量个数，另一个是k，表示查找最相似的前k个向量即top-k，向量检索有如下两类方法 ：</p>
<blockquote>
<p>存在最近邻检索（Nearest Neighbor Search，NN）和近似最近邻检索（Approximate Nearest Neighbor Search， ANN）。NN 最初是用目标向量和数据库向量逐条计算距离，结果最为精确，后来又产生了相关算法（比如 KD-tree），使得搜索效率大为提高，但在应对海量高维度数据时显得力不从心。ANN 则是在可接受的精度条件下通过把向量分簇建立索引，大幅提高搜索效率，这也大规模向量检索场景下所使用的主要方法</p>
</blockquote>
<p>这里的向量分簇其实就是聚类，将向量按标准（取决于聚类算法）进行分类，向量进行聚类后分成很多簇，每个簇都有一个中心向量，当用户输入目标向量进行搜索时，先与中心向量进行相似度计算，挑选出距离最近的几个簇，然后再把目标向量与选中的簇里的每一条向量继续做相似度计算，最后得出top-k。</p>
<p>当向量规模足够大时就面临着海量数据持久化及检索性能的问题：</p>
<blockquote>
<p>大规模向量检索的系统作为一个向量数据库，不但要能够支持海量数据的持久化，还要能快速地检索出用户需要的信息。生产环境中的向量维度一般起步就是128维，高一些的可达512维。我们可以算一下，对于512维度的向量，每条向量有512个数值，通常在计算机里这些数值是以 float 类型表示，这意味着每条向量将会占用2048字节，那么一亿条这样的向量就会用掉200 GB。而生产环境中的向量数量有可能达到十亿甚至百亿的规模。</p>
</blockquote>
<p>目前，我们无需深入了解向量聚类及相似度计算算法，可借助一些热门的向量检索框架，达到直接实现简单向量检索的需求。</p>
<h2 id="三-faiss">三、Faiss</h2>
<h3 id="whats-faiss">What's Faiss?</h3>
<p>Faiss是由Facebook AI团队开发的一个向量搜索库，我们来看下Facebook官方对其的解释：</p>
<blockquote>
<p>Faiss is a library for efficient similarity search and clustering of dense vectors. It contains algorithms that search in sets of vectors of any size, up to ones that possibly do not fit in RAM. It also contains supporting code for evaluation and parameter tuning. Faiss is written in C++ with complete wrappers for Python (versions 2 and 3). Some of the most useful algorithms are implemented on the GPU</p>
</blockquote>
<p>总结一下，其实就是一个用C++编写、Python包装的用于高性能相似度搜索和密集向量聚类的库，并且它还包含了可以搜索任意大小的向量集的算法。我们来看下它有什么特性：</p>
<h3 id="faiss特性">Faiss特性</h3>
<ul>
<li>支持向量相似度检索和聚类</li>
<li>支持多种索引方式</li>
<li>支持CPU和GPU计算</li>
<li>支持Python和C++调用</li>
</ul>
<p>提到搜索，当然少不了索引，再来看下它支持的索引类型：</p>
<h3 id="faiss索引类型">Faiss索引类型</h3>
<p>Faiss索引分为基本索引、二进制索引，以及基于前两种的综合索引，先来了解下Faiss的基本索引，关于索引的详细信息可移步<a href="https://github.com/facebookresearch/faiss/wiki/Faiss-indexes">Faiss Github</a>进一步学习。</p>
<ul>
<li>Exact Search for L2 (基于L2距离的确定搜索匹配)</li>
<li>Exact Search for Inner Product (基于内积的确定搜索匹配)</li>
<li>Hierarchical Navigable Small World graph exploration (分层索引)</li>
<li>Inverted file with exact post-verification (倒排索引)</li>
<li>Locality-Sensitive Hashing (binary flat index) (本地敏感hash)</li>
<li>Scalar quantizer (SQ) in flat mode (标量量化索引)</li>
<li>Product quantizer (PQ) in flat mode (乘积量化索引)</li>
<li>IVF and scalar quantizer (倒排+标量量化索引)</li>
<li>IVFADC (coarse quantizer+PQ on residuals) (倒排+乘积量化索引)</li>
<li>IVFADC+R (same as IVFADC with re-ranking based on codes) (倒排+乘积量化索引 + 基于编码器重排索引)</li>
</ul>
<p>作为一个向量检索的门外汉，一眼看到这些索引类型的名字基本懵了，知道Lucene的童鞋肯定知道上面第四个倒排索引，关于以上索引类型的详细介绍及使用场景，可参考<a href="https://github.com/facebookresearch/faiss/wiki/Faiss-indexes">Faiss-indexes</a>，上面都有完整的介绍及使用demo，这里就不再赘述（翻译）了，可以重点学习下<a href="https://mccormickml.com/2017/10/13/product-quantizer-tutorial-part-1/">PQ</a>（乘积量化）哦，它是Faiss的核心。</p>
<h2 id="四-milvus">四、Milvus</h2>
<h3 id="whats-milvus">What's Milvus?</h3>
<p>同样Milvus也是用于做向量检索的，我们来看下Milvus官网对其的介绍：</p>
<blockquote>
<p>Milvus 是一款开源的、针对海量特征向量的相似性搜索引擎。基于异构众核计算框架设计，成本更低，性能更好。 在有限的计算资源下，十亿向量搜索仅毫秒响应。Milvus 能够广泛应用于各种 AI 场景，为 AI 发展提供有效助力</p>
</blockquote>
<p>我们来挑几个关键词，“特征向量”、“搜索引擎”、“毫秒响应”，再来看看它的特性：</p>
<h3 id="milvus特性">Milvus特性</h3>
<blockquote>
<ul>
<li>异构计算：Milvus采用异构计算架构设计，以实现最佳性能和成本效率。</li>
<li>多种索引：Milvus支持多种索引类型，这些索引类型采用量化，基于树的索引和图形索引技术。</li>
<li>智能资源管理：Milvus根据您的数据集和可用资源自动调整搜索计算和索引构建过程。</li>
<li>横向可扩展性：Milvus支持在线/离线扩展，可通过简单的命令扩展存储和计算资源。</li>
<li>高可用性：Milvus与Kubernetes框架集成在一起，因此可以避免所有单点故障。</li>
<li>高兼容性：Milvus与几乎所有深度学习模型和主要编程语言（例如Python，Java和C ++等）兼容。</li>
<li>使用方便：只需几个步骤，即可轻松安装Milvus，并使您能够专注于特征向量。</li>
<li>可视化监控器：您可以在基于Prometheus的GUI监视器仪表板上跟踪系统性能。</li>
</ul>
</blockquote>
<p>咋一看，特性明显比Faiss多了不少，还带有资源管理及对高可用、高兼容的支持，似乎比Faiss好用多了。来看下它的索引类型：</p>
<h3 id="mivus索引类型">Mivus索引类型</h3>
<blockquote>
<p><img src="https://orange-hou.github.io//post-images/1584285776054.png" alt="" loading="lazy"><br>
注：图片来源（https://www.milvus.io/docs/v0.6.0/reference/index.md ）</p>
</blockquote>
<p>索引类型不多，目前CPU版Milvus建议采用IVFSQ8，GPU版Milvus建议采用IVFSQ8H，同样，Mivlus官网及博客上有关于索引的详细介绍及测试报告，可移步官网进一步学习。</p>
<h2 id="五-sptag">五、SPTAG</h2>
<h3 id="whats-sptag">What's SPTAG?</h3>
<p>SPTAG是由微软开发的，来看下微软对其的介绍：</p>
<blockquote>
<p>This library assumes that the samples are represented as vectors and that the vectors can be compared by L2 distances or cosine distances. Vectors returned for a query vector are the vectors that have smallest L2 distance or cosine distances with the query vector.</p>
<p>SPTAG provides two methods: kd-tree and relative neighborhood graph (SPTAG-KDT) and balanced k-means tree and relative neighborhood graph (SPTAG-BKT). SPTAG-KDT is advantageous in index building cost, and SPTAG-BKT is advantageous in search accuracy in very high-dimensional data</p>
</blockquote>
<p>有点抽象，我们简单总结一下，SPTAG是通过L2距离和余弦距离来比较向量，是一个基于最近邻搜索的向量检索算法库。</p>
<p>关于SPTAG由于当前并不是非常流行，相比前两种框架使用者较少，因而暂不继续研究下去。</p>
<h2 id="六-简单的对比">六、简单的对比</h2>
<p>知道了如上三种常用的向量检索框架，我们再来对它们做一个对比总结，其实最本质的区别就是Faiss和SPTAG都是搜索库，而Milvus是搜索引擎，嗯，有点类似Luene和Solr/Elasticsearch的关系，当然Milvus底层用到了Faiss，而SPTAG与这两者似乎没啥调用与被调用关系，Mivus官网有一张对比图，已经讲得很清楚了：</p>
<blockquote>
<p><img src="https://orange-hou.github.io//post-images/1584285803536.jpg" alt="" loading="lazy"><br>
注：图片来源（https://www.milvus.io/cn/docs/v0.6.0/reference/comparison.md ）</p>
</blockquote>
<p>不过要注意，Faiss和SPTAG是没有Java SDK的哦，想要用Java调用的同学，需要用JNI进一步封装。最后我们挑些重点再总结一下：</p>
<table>
<thead>
<tr>
<th style="text-align:center">\</th>
<th style="text-align:center">Faiss</th>
<th style="text-align:center">Milvus</th>
<th style="text-align:center">SPTAG</th>
</tr>
</thead>
<tbody>
<tr>
<td style="text-align:center">本质</td>
<td style="text-align:center">搜索算法库</td>
<td style="text-align:center">搜索引擎</td>
<td style="text-align:center">近似最近邻搜索库</td>
</tr>
<tr>
<td style="text-align:center">上手/使用难易</td>
<td style="text-align:center">较难，需有相关经验及知识储备</td>
<td style="text-align:center">较易</td>
<td style="text-align:center">较难，需有相关经验</td>
</tr>
<tr>
<td style="text-align:center">支持Java</td>
<td style="text-align:center">不支持</td>
<td style="text-align:center">支持</td>
<td style="text-align:center">不支持</td>
</tr>
<tr>
<td style="text-align:center">典型应用场景</td>
<td style="text-align:center">多媒体文件相似度搜索</td>
<td style="text-align:center">图片搜索、视频处理、自然语言分析、声纹识别和音频搜索</td>
<td style="text-align:center">图片搜索、语义匹配</td>
</tr>
</tbody>
</table>
<h2 id="参考资料">参考资料</h2>
<ol>
<li>
<p><a href="https://github.com/facebookresearch/faiss/wiki">Faiss wiki(https://github.com/facebookresearch/faiss/wiki)</a></p>
</li>
<li>
<p><a href="https://www.milvus.io/cn/docs/v0.6.0/about_milvus/overview.md">Milvus官方文档(https://www.milvus.io/cn/docs/v0.6.0/about_milvus/overview.md)</a></p>
</li>
<li>
<p><a href="https://www.milvus.io/cn/blogs/2019-11-07-massive-vector-search.md">大规模向量检索(https://www.milvus.io/cn/blogs/2019-11-07-massive-vector-search.md)</a></p>
</li>
<li>
<p><a href="https://github.com/facebookresearch/faiss/wiki">SPTAG wiki(https://github.com/microsoft/SPTAG)</a></p>
</li>
</ol>
]]></content>
    </entry>
</feed>